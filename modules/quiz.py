import streamlit as st
import random
import time

class QuizModule:
    def __init__(self):
        self.all_questions = self.load_questions()
    
    def load_questions(self):
        """L√§dt alle Fragen inklusive der neuen Erweiterungen"""
        return [
            # üìä BASIS-FRAGEN (bestehende Typen)
            {
                "id": 1, "difficulty": 1,
                "type": "likert_interpretation",
                "question": "Wie wahrscheinlich ist diese Interpretation des Verhaltens?",
                "scenario": "Eine Person beginnt jeden Tag um 7:00 Uhr, arbeitet strukturiert mit To-Do-Listen, und erledigt alle Aufgaben termingerecht.",
                "interpretations": [
                    "Hohe Gewissenhaftigkeit (strukturierte Arbeitsweise)",
                    "Niedrige Offenheit (Angst vor Spontaneit√§t)", 
                    "Hoher Neurotizismus (Kontrollzwang)",
                    "Situative Anpassung (Probezeit)"
                ],
                "correct_likert": [4, 2, 3, 3],
                "probabilistic_feedback": {
                    "Gewissenhaftigkeit": "85%",
                    "Neurotizismus": "45%", 
                    "Situativ": "35%",
                    "Offenheit": "15%"
                },
                "explanation": "üîç **Klassischer Fall hoher Gewissenhaftigkeit:** Struktur und P√ºnktlichkeit sind Kernmerkmale. Neurotizismus w√§re nur bei √§ngstlicher √úberkontrolle wahrscheinlicher.",
                "learning_point": "Gewissenhaftigkeit zeigt sich in konsistenter Organisation √ºber Zeit hinweg."
            },
            {
                "id": 2, "difficulty": 1,
                "type": "multiple_correct",
                "question": "Welche Dimensionen erkl√§ren dieses Verhalten am besten?",
                "scenario": "Jemand geht auf Partys auf fremde Menschen zu, initiiert Gespr√§che und scheint Energie aus sozialen Kontakten zu ziehen.",
                "options": [
                    "Hohe Extraversion (Geselligkeit, Energiegewinn)",
                    "Niedrige Vertr√§glichkeit (Aufdringlichkeit)",
                    "Hohe Offenheit (Interesse an neuen Menschen)",
                    "Niedriger Neurotizismus (soziale Sicherheit)"
                ],
                "correct_answers": [0, 3],
                "explanation": "üíÉ **Extraversions-Muster:** Soziale Initiative + Energiegewinn = klassische Extraversion. Geringe soziale √Ñngste (niedriger Neurotizismus) unterst√ºtzen dieses Verhalten.",
                "learning_point": "Extraversion ‚â† nur Geselligkeit, sondern auch Energiegewinn aus Sozialkontakten."
            },
            
            # üîÆ PH√ÑNOMEN-DEUTUNG (Konjunktivisch)
            {
                "id": 101, "difficulty": 2,
                "type": "phenomenon_interpretation",
                "question": "Wie k√∂nnte dieses Verhalten im Rahmen der Big Five gedeutet werden?",
                "scenario": "Eine Patientin in der Therapie vermeidet Blickkontakt, spricht sehr leise und z√∂gert lange vor Antworten. Sie wirkt angespannt, aber kooperativ.",
                "phenomenon": "Sozialer R√ºckzug + gehemmte Kommunikation",
                "possible_interpretations": [
                    "Hoher Neurotizismus (soziale √Ñngstlichkeit, Unsicherheit)",
                    "Niedrige Extraversion (introvertierte Grundtendenz)", 
                    "Hohe Vertr√§glichkeit (unterw√ºrfiges, konfliktscheues Verhalten)",
                    "Situative Reaktion (Scham, akute Belastung, Therapieangst)",
                    "Kombination aus Neurotizismus und niedriger Extraversion"
                ],
                "valid_hypotheses": [0, 1, 2, 3, 4],
                "most_plausible": [0, 4, 3],
                "explanation": "üîç **Mehrdeutige Ph√§nomendeutung:** Dieses Verhaltensmuster k√∂nnte auf soziale √Ñngstlichkeit (Neurotizismus) ODER introvertierte Grundtendenz ODER situative Scham hindeuten. Entscheidend: Wie verh√§lt sich die Person in anderen Kontexten?",
                "learning_point": "Identische Verhaltensmuster k√∂nnen unterschiedliche Ursachen haben - Kontext und Verlaufsbeobachtung sind entscheidend."
            },
            
            # ‚è±Ô∏è FALLVERL√ÑUFE (Trait vs. State)
            {
                "id": 102, "difficulty": 3,
                "type": "case_progression",
                "question": "Handelt es sich um einen Pers√∂nlichkeitsstil oder einen situativen Zustand?",
                "scenario": "**Woche 1-4:** Herr Meyer wirkt im Team ruhig, aber kompetent. Er spricht wenig, aber wenn, dann pr√§zise.\n\n**Woche 5-8:** Seit einem gescheiterten Projekt wirkt er zunehmend gereizt, kritisiert Kollegen, wirkt misstrauisch.\n\n**Woche 9-12:** Das Verhalten normalisiert sich langsam, aber die grundlegende Zur√ºckhaltung bleibt.",
                "timeline": [
                    {"phase": "Baseline", "verhalten": "Ruhig, kompetent, pr√§zise"},
                    {"phase": "Akutphase", "verhalten": "Gereizt, kritisch, misstrauisch"}, 
                    {"phase": "Erholung", "verhalten": "Normalisierung, aber grunds√§tzlich zur√ºckhaltend"}
                ],
                "interpretation_task": "Bewerten Sie die Stabilit√§t vs. Situativit√§t:",
                "options": [
                    "Stabiler Pers√∂nlichkeitsstil (niedrige Extraversion) mit situativer √úberlagerung",
                    "Prim√§r situative Reaktion (Projektstress) auf normalerweise extravertierter Basis",
                    "Entwicklung einer Pers√∂nlichkeits√§nderung (erh√∂hter Neurotizismus)",
                    "Kombination aus stabiler Introversion + akuter Belastungsreaktion"
                ],
                "correct_interpretation": [0, 3],
                "explanation": "‚è±Ô∏è **Verlaufsdiagnostik:** Die stabile Grundtendenz (Zur√ºckhaltung) spricht f√ºr niedrige Extraversion. Die akute Ver√§nderung deutet auf situative √úberlagerung (Stressreaktion) hin. Die R√ºckkehr zur Baseline spricht gegen dauerhafte Pers√∂nlichkeits√§nderung.",
                "learning_point": "Verlaufsbeobachtung unterscheidet stabile Traits von state-abh√§ngigen Reaktionen."
            },
            
            # ‚ö†Ô∏è DIAGNOSTISCHE FEHLERFALLEN
            {
                "id": 103, "difficulty": 3, 
                "type": "diagnostic_pitfall",
                "question": "Welche diagnostische Fehlerfalle wird hier provoziert?",
                "scenario": "Ein Therapeut liest im Assessment: 'Hohe Offenheit, niedrige Vertr√§glichkeit'. In der Sitzung berichtet der Klient von Konflikten mit Autorit√§tspersonen. Der Therapeut interpretiert: 'Typisch bei niedriger Vertr√§glichkeit - da m√ºssen wir an Ihrer Kooperationsf√§higkeit arbeiten.'",
                "pitfall_type": "Confirmation Bias + Overpathologizing",
                "critical_elements": [
                    "Vorschnelle Verkn√ºpfung von Assessment und Einzelverhalten",
                    "Ignorieren situativer Faktoren (berechtigte Kritik?)", 
                    "Pathologisierung normaler Verhaltensvarianz",
                    "Fehlende Ber√ºcksichtigung des Kontexts"
                ],
                "options": [
                    "Confirmation Bias (Suche nach best√§tigenden Informationen)",
                    "Overpathologizing (Normalvariation als Problem sehen)",
                    "Fundamental Attribution Error (dispositional √ºbersch√§tzen)",
                    "Alle genannten Fehlerfallen"
                ],
                "correct_answers": [3],
                "explanation": "üéØ **Diagnostische Fallstricke:** Hier wirken mehrere Biases: Confirmation Bias (Assessment-Daten dominieren), Overpathologizing (Konfliktverhalten ‚â† St√∂rung), Fundamental Attribution Error (situative Faktoren ignorieren). Wichtig: Assessment-Daten sind Hypothesen, keine Diagnosen!",
                "learning_point": "Assessment-Daten generieren Hypothesen - keine vorschnellen Kausalzuschreibungen!"
            },
            
            # üìà INTERAKTIVE LIKELIHOOD-SCH√ÑTZUNGEN  
            {
                "id": 104, "difficulty": 2,
                "type": "probability_estimation",
                "question": "Sch√§tzen Sie die Wahrscheinlichkeit jeder Hypothese (in %):",
                "scenario": "Ein sonst zuverl√§ssiger Mitarbeiter liefert pl√∂tzlich unvollst√§ndige Arbeiten ab, wirkt unkonzentriert und vergesslich. Dies seit 3 Wochen.",
                "hypotheses": [
                    "Akute private Belastung (Familie, Gesundheit)",
                    "Beginnendes Burnout (berufliche √úberlastung)",
                    "Nachlassende Gewissenhaftigkeit (Pers√∂nlichkeits√§nderung)", 
                    "Situative Demotivation (Konflikte, fehlende Anerkennung)"
                ],
                "expert_probabilities": [45, 25, 10, 20],
                "tolerance_range": 15,
                "explanation": "üìà **Probabilistisches Reasoning:** Akute private Belastung ist am wahrscheinlichsten (pl√∂tzliche Ver√§nderung bei vorher stabiler Person). Burnout und situative Faktoren sind m√∂glich. Reine Pers√∂nlichkeits√§nderung ist unwahrscheinlich (zu kurzer Zeitraum).",
                "learning_point": "Klinisches Urteilen erfordert Wahrscheinlichkeitsabw√§gungen, nicht bin√§re Entscheidungen."
            },
            
            # üí° STRATEGIE-FRAGEN (Umgangsleitlinien)
            {
                "id": 105, "difficulty": 2,
                "type": "intervention_strategy", 
                "question": "Welche Reaktion w√§re hier am angemessensten?",
                "scenario": "Im Team f√§llt eine Mitarbeiterin durch extrem detaillierte, aber sehr langsame Arbeit auf. Projekte verz√∂gern sich, Kollegen werden ungeduldig. Die Mitarbeiterin wirkt dabei nicht √§ngstlich, sondern konzentriert und zufrieden.",
                "personality_profile": "Hohe Gewissenhaftigkeit (Perfektionismus) bei normalem Neurotizismus",
                "strategic_options": [
                    "Klare Deadlines setzen + Qualit√§tskriterien definieren (Struktur geben)",
                    "Perfektionismus thematisieren + psychologische Unterst√ºtzung anbieten",
                    "Aufgaben an St√§rken anpassen (Qualit√§tskontrolle statt Zeitdruck)",
                    "Team-Feedback einholen + Gruppendruck nutzen"
                ],
                "recommended_strategies": [0, 2],
                "explanation": "üíº **Personzentrierte Intervention:** Da kein Leidensdruck (kein Neurotizismus) besteht, sind strukturelle L√∂sungen besser als Pathologisierung. Deadlines setzen + St√§rken nutzen (Qualit√§tsarbeit) statt 'Therapieren' eines funktionalen Pers√∂nlichkeitsmerkmals.",
                "learning_point": "Interventionen sollten zum Pers√∂nlichkeitsprofil passen - nicht jedes Merkmal muss 'behandelt' werden."
            },
            
            # üß© ERWEITERTE KOMBINATIONSFRAGEN
            {
                "id": 106, "difficulty": 3,
                "type": "complex_combination", 
                "question": "Welche Dimensionen-Kombination erkl√§rt dieses komplexe Muster?",
                "scenario": "Eine Person initiiert intensiven philosophischen Austausch (tiefe Gespr√§che), zeigt aber wenig Interesse an oberfl√§chlichem Smalltalk. In Gruppen dominant bei intellektuellen Themen, aber zur√ºckhaltend bei pers√∂nlichen Themen. Sehr wertorientiert in Entscheidungen.",
                "behavior_pattern": "Selektive Soziabilit√§t + intellektuelle Dominanz + Wertorientierung",
                "dimension_combinations": [
                    "Hohe Offenheit + niedrige Extraversion (intellektuell interessierter Introvertierter)",
                    "Hohe Offenheit + hohe Gewissenhaftigkeit (prinzipienorientierter Intellektueller)", 
                    "Hohe Offenheit + niedrige Vertr√§glichkeit (egozentrischer Denker)",
                    "Hohe Offenheit + hohe Extraversion + hohe Gewissenhaftigkeit (komplexes Profil)"
                ],
                "correct_combination": [0, 1],
                "explanation": "üé≠ **Komplexes Interaktionsmuster:** Hohe Offenheit erkl√§rt das intellektuelle Interesse. Die selektive Soziabilit√§t (tiefe vs. oberfl√§chliche Gespr√§che) deutet auf introvertierte Tendenzen hin. Die Wertorientierung spricht f√ºr Gewissenhaftigkeit. Keine Hinweise auf niedrige Vertr√§glichkeit.",
                "learning_point": "Komplexe Verhaltensmuster erfordern oft Mehrfach-Kombinationen von Dimensionen."
            }
        ]
    
    def display_quiz(self):
        """Zeigt das Quiz mit Auswahlm√∂glichkeit f√ºr Gr√∂√üe"""
        st.header("üß† Big Five Clinical Reasoning Master Quiz")
        
        # Initialisierung des Session States
        if 'quiz_initialized' not in st.session_state:
            st.session_state.quiz_initialized = True
            st.session_state.quiz_configurated = False
            st.session_state.quiz_started = False
            st.session_state.current_question = 0
            st.session_state.score = 0
            st.session_state.user_answers = {}
            st.session_state.show_results = False
        
        if not st.session_state.quiz_configurated:
            self.show_quiz_configuration()
            return
        
        if not st.session_state.quiz_started:
            self.show_quiz_intro()
            return
        
        if st.session_state.show_results:
            self.show_results()
        elif st.session_state.current_question < len(st.session_state.quiz_questions):
            self.show_question()
        else:
            st.session_state.show_results = True
            st.rerun()
    
    def show_quiz_configuration(self):
        """Zeigt die Konfiguration f√ºr Quiz-Gr√∂√üe"""
        st.markdown("## üéØ Quiz konfigurieren")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("üî¨ Kleines Quiz")
            st.markdown("""
            - **4 Fragen** (ca. 10 Minuten)
            - **Gemischt**: Verschiedene Fragetypen
            """)
            if st.button("Kleines Quiz starten", use_container_width=True, key="btn_small"):
                self.setup_quiz("small")
        
        with col2:
            st.subheader("üéì Gro√ües Quiz") 
            st.markdown("""
            - **8 Fragen** (ca. 20 Minuten)
            - **Vollst√§ndig**: Alle Fragetypen
            """)
            if st.button("Gro√ües Quiz starten", use_container_width=True, key="btn_large"):
                self.setup_quiz("large")
    
    def setup_quiz(self, quiz_size):
        """Bereitet das Quiz mit zuf√§lliger Fragenauswahl vor"""
        all_questions = self.all_questions.copy()
        random.shuffle(all_questions)
        
        if quiz_size == "small":
            questions = all_questions[:4]
        else:
            questions = all_questions[:8]
        
        random.shuffle(questions)
        st.session_state.quiz_questions = questions
        st.session_state.quiz_configurated = True
        st.session_state.quiz_size = quiz_size
        st.rerun()
    
    def show_quiz_intro(self):
        """Zeigt die Quiz-Einleitung"""
        question_count = len(st.session_state.quiz_questions)
        
        st.success(f"**üéØ Quiz konfiguriert: {question_count} Fragen**")
        st.info("""
        **üìö Denken Sie in:**
        - Wahrscheinlichkeiten, nicht Gewissheiten
        - Mehreren Interpretationen, nicht einer Wahrheit  
        - Konjunktiv: *"k√∂nnte hindeuten auf..."*
        """)
        
        if st.button("üéØ Quiz jetzt starten", type="primary", use_container_width=True, key="btn_start_quiz"):
            st.session_state.quiz_started = True
            st.session_state.start_time = time.time()
            st.rerun()
    
    def show_question(self):
        """Zeigt die aktuelle Frage - KORRIGIERTE VERSION"""
        question_data = st.session_state.quiz_questions[st.session_state.current_question]
        
        # Fortschrittsanzeige
        progress = (st.session_state.current_question + 1) / len(st.session_state.quiz_questions)
        st.progress(progress)
        st.caption(f"Frage {st.session_state.current_question + 1} von {len(st.session_state.quiz_questions)}")
        
        # Schwierigkeitsgrad
        difficulty_icons = {1: "üü¢", 2: "üü°", 3: "üî¥"}
        st.write(f"{difficulty_icons[question_data['difficulty']]} **Schwierigkeitsgrad {question_data['difficulty']}/3**")
        
        st.markdown(f"### {question_data['question']}")
        
        if question_data.get('scenario'):
            with st.expander("üìã Fallvignette anzeigen", expanded=True):
                st.write(question_data['scenario'])
        
        # Fragetyp-spezifische Anzeige
        question_type_handlers = {
            'likert_interpretation': self.show_likert_question,
            'multiple_correct': self.show_multiple_correct_question,
            'phenomenon_interpretation': self.show_phenomenon_interpretation,
            'case_progression': self.show_case_progression,
            'diagnostic_pitfall': self.show_diagnostic_pitfall,
            'probability_estimation': self.show_probability_estimation,
            'intervention_strategy': self.show_intervention_strategy,
            'complex_combination': self.show_complex_combination
        }
        
        handler = question_type_handlers.get(question_data['type'])
        if handler:
            handler(question_data)
        else:
            st.error(f"Unbekannter Fragetyp: {question_data['type']}")
    
    # ========== FRAGETYP-METHODEN ==========
    
    def show_likert_question(self, question_data):
        """Zeigt Likert-Skalen Fragen"""
        st.write("**Bewerten Sie auf einer Skala von 1-5:**")
        st.caption("1 = sehr unwahrscheinlich, 3 = neutral, 5 = sehr wahrscheinlich")
        
        user_ratings = []
        for i, interpretation in enumerate(question_data['interpretations']):
            rating = st.slider(
                f"{interpretation}",
                min_value=1, max_value=5, value=3,
                key=f"likert_{question_data['id']}_{i}"
            )
            user_ratings.append(rating)
        
        if st.button("üìä Bewertungen analysieren", type="primary", key=f"btn_likert_{question_data['id']}"):
            self.evaluate_likert_question(user_ratings, question_data)
    
    def show_multiple_correct_question(self, question_data):
        """Zeigt Multiple-Choice-Fragen"""
        st.write("**W√§hlen Sie alle korrekten Aussagen:**")
        
        user_answers = st.multiselect(
            "Mehrfachauswahl:",
            question_data["options"],
            key=f"multiple_{question_data['id']}"
        )
        
        if st.button("‚úÖ Antworten pr√ºfen", type="primary", key=f"btn_multiple_{question_data['id']}"):
            self.evaluate_multiple_correct_question(user_answers, question_data)
    
    def show_phenomenon_interpretation(self, question_data):
        """Zeigt Ph√§nomen-Deutungs-Fragen"""
        st.write("**Welche Interpretationen sind wissenschaftlich plausibel?**")
        st.caption("Mehrere Antworten k√∂nnen richtig sein - denken Sie im Konjunktiv!")
        
        user_answers = st.multiselect(
            "W√§hlen Sie plausible Hypothesen:",
            question_data["possible_interpretations"],
            key=f"phenomenon_{question_data['id']}"
        )
        
        if st.button("üîÆ Hypothesen bewerten", type="primary", key=f"btn_phenomenon_{question_data['id']}"):
            self.evaluate_phenomenon_interpretation(user_answers, question_data)
    
    def show_case_progression(self, question_data):
        """Zeigt Fallverlaufs-Fragen"""
        st.write("**Analyse des Verhaltens √ºber Zeit:**")
        
        # Timeline anzeigen
        for event in question_data["timeline"]:
            st.write(f"**{event['phase']}:** {event['verhalten']}")
        
        st.write(f"**{question_data['interpretation_task']}**")
        
        user_answers = st.multiselect(
            "W√§hlen Sie zutreffende Interpretationen:",
            question_data["options"],
            key=f"case_{question_data['id']}"
        )
        
        if st.button("‚è±Ô∏è Verlaufsanalyse", type="primary", key=f"btn_case_{question_data['id']}"):
            self.evaluate_case_progression(user_answers, question_data)
    
    def show_diagnostic_pitfall(self, question_data):
        """Zeigt diagnostische Fehlerfallen"""
        st.warning("‚ö†Ô∏è **Achtung - diese Frage testet Ihre methodische Kritikf√§higkeit!**")
        
        st.write("**Kritische Elemente in dieser Situation:**")
        for element in question_data["critical_elements"]:
            st.write(f"‚Ä¢ {element}")
        
        user_answers = st.multiselect(
            "Welche Fehlerfallen wirken hier?",
            question_data["options"],
            key=f"pitfall_{question_data['id']}"
        )
        
        if st.button("üéØ Fallen analysieren", type="primary", key=f"btn_pitfall_{question_data['id']}"):
            self.evaluate_diagnostic_pitfall(user_answers, question_data)
    
    def show_probability_estimation(self, question_data):
        """Zeigt Likelihood-Sch√§tzungen"""
        st.write("**Sch√§tzen Sie die Wahrscheinlichkeit jeder Hypothese (0-100%):**")
        
        user_probabilities = []
        for i, hypothesis in enumerate(question_data["hypotheses"]):
            prob = st.slider(
                f"{hypothesis}",
                min_value=0, max_value=100, value=25,
                key=f"prob_{question_data['id']}_{i}"
            )
            user_probabilities.append(prob)
        
        # Pr√ºfen ob Summe ~100%
        total = sum(user_probabilities)
        if total != 100:
            st.warning(f"‚ö†Ô∏è Summe: {total}% (sollte 100% ergeben)")
        
        if st.button("üìà Sch√§tzung analysieren", type="primary", key=f"btn_prob_{question_data['id']}"):
            self.evaluate_probability_estimation(user_probabilities, question_data)
    
    def show_intervention_strategy(self, question_data):
        """Zeigt Strategie-Fragen"""
        st.write("**Welche Umgangsstrategie w√§re angemessen?**")
        st.info(f"**Pers√∂nlichkeitsprofil:** {question_data['personality_profile']}")
        
        user_answers = st.multiselect(
            "W√§hlen Sie passende Interventionen:",
            question_data["strategic_options"],
            key=f"strategy_{question_data['id']}"
        )
        
        if st.button("üí° Strategien bewerten", type="primary", key=f"btn_strategy_{question_data['id']}"):
            self.evaluate_intervention_strategy(user_answers, question_data)
    
    def show_complex_combination(self, question_data):
        """Zeigt erweiterte Kombinationsfragen"""
        st.write("**Komplexes Verhaltensmuster analysieren:**")
        st.info(f"**Muster:** {question_data['behavior_pattern']}")
        
        user_answers = st.multiselect(
            "Welche Dimensionen-Kombinationen erkl√§ren dieses Muster?",
            question_data["dimension_combinations"],
            key=f"complex_{question_data['id']}"
        )
        
        if st.button("üß© Kombination analysieren", type="primary", key=f"btn_complex_{question_data['id']}"):
            self.evaluate_complex_combination(user_answers, question_data)

    # ========== EVALUATIONS-METHODEN ==========
    
    def evaluate_likert_question(self, user_ratings, question_data):
        """Bewertet Likert-Skalen Fragen"""
        correct_ratings = question_data['correct_likert']
        deviations = [abs(user - correct) for user, correct in zip(user_ratings, correct_ratings)]
        accuracy = max(0, 100 - (sum(deviations) / (len(correct_ratings) * 4)) * 100)
        
        st.subheader("üìä Auswertung")
        
        if accuracy >= 80:
            st.success(f"üéâ Exzellente Einsch√§tzung! ({accuracy:.1f}%)")
        elif accuracy >= 60:
            st.warning(f"üëç Gute Einsch√§tzung ({accuracy:.1f}%)")
        else:
            st.error(f"üìö Abweichungen ({accuracy:.1f}%)")
        
        with st.expander("üìö Erkl√§rung", expanded=True):
            st.info(question_data["explanation"])
        
        self.show_next_button(question_data)
    
    def evaluate_multiple_correct_question(self, user_answers, question_data):
        """Bewertet Multiple-Choice-Fragen"""
        user_indices = [question_data["options"].index(ans) for ans in user_answers]
        correct_indices = question_data["correct_answers"]
        correct_selected = len(set(user_indices) & set(correct_indices))
        incorrect_selected = len(set(user_indices) - set(correct_indices))
        
        st.subheader("‚úÖ Auswertung")
        
        if correct_selected == len(correct_indices) and incorrect_selected == 0:
            st.success("üéâ Perfekt! Vollst√§ndiges Wissen.")
            st.session_state.score += 1
        elif incorrect_selected == 0:
            st.warning("üëç Korrekt, aber nicht vollst√§ndig.")
        else:
            st.error("üìö Enth√§lt Fehler.")
        
        with st.expander("üìö Erkl√§rung", expanded=True):
            st.info(question_data["explanation"])
        
        self.show_next_button(question_data)
    
    def evaluate_phenomenon_interpretation(self, user_answers, question_data):
        """Bewertet Ph√§nomen-Deutungen"""
        user_indices = [question_data["possible_interpretations"].index(ans) for ans in user_answers]
        correct_selections = len(set(user_indices) & set(question_data["valid_hypotheses"]))
        
        st.subheader("üîÆ Mehrdeutige Ph√§nomendeutung")
        
        if correct_selections == len(question_data["valid_hypotheses"]):
            st.success("üéâ Vollst√§ndiges Hypothesenspektrum erkannt!")
            st.session_state.score += 1
        else:
            st.warning("üëç Gute Auswahl - mehrere Perspektiven bedacht")
        
        st.write("**Wahrscheinlichste Hypothesen:**")
        for idx in question_data["most_plausible"]:
            st.write(f"‚Ä¢ {question_data['possible_interpretations'][idx]}")
        
        with st.expander("üìö Wissenschaftliche Einordnung", expanded=True):
            st.info(question_data["explanation"])
        
        self.show_next_button(question_data)
    
    def evaluate_case_progression(self, user_answers, question_data):
        """Bewertet Fallverlaufs-Analysen"""
        user_indices = [question_data["options"].index(ans) for ans in user_answers]
        correct_indices = question_data["correct_interpretation"]
        
        st.subheader("‚è±Ô∏è Verlaufsdiagnostik")
        
        if set(user_indices) == set(correct_indices):
            st.success("üéâ Exzellente Verlaufsanalyse!")
            st.session_state.score += 1
        else:
            st.error("‚ùå Differenzierung zwischen Trait und State verbesserungsf√§hig")
        
        with st.expander("üìö Verlaufsinterpretation", expanded=True):
            st.info(question_data["explanation"])
        
        self.show_next_button(question_data)
    
    def evaluate_diagnostic_pitfall(self, user_answers, question_data):
        """Bewertet Fehlerfallen-Erkennung"""
        user_indices = [question_data["options"].index(ans) for ans in user_answers]
        correct_indices = question_data["correct_answers"]
        
        st.subheader("‚ö†Ô∏è Methodenkritische Reflexion")
        
        if set(user_indices) == set(correct_indices):
            st.success("üéâ Exzellente Fehlerfallen-Erkennung!")
            st.session_state.score += 1
        else:
            st.warning("üìö Diagnostische Biases nicht vollst√§ndig erkannt")
        
        with st.expander("üìö Kritische Reflexion", expanded=True):
            st.info(question_data["explanation"])
        
        self.show_next_button(question_data)
    
    def evaluate_probability_estimation(self, user_probabilities, question_data):
        """Bewertet Wahrscheinlichkeitssch√§tzungen"""
        expert_probs = question_data["expert_probabilities"]
        tolerance = question_data["tolerance_range"]
        
        deviations = [abs(user - expert) for user, expert in zip(user_probabilities, expert_probs)]
        within_tolerance = sum(1 for dev in deviations if dev <= tolerance)
        accuracy = (within_tolerance / len(deviations)) * 100
        
        st.subheader("üìà Probabilistisches Clinical Reasoning")
        
        if accuracy >= 80:
            st.success(f"üéâ Exzellente Wahrscheinlichkeitseinsch√§tzung! ({accuracy:.1f}%)")
            st.session_state.score += 1
        elif accuracy >= 60:
            st.warning(f"üëç Gute Einsch√§tzung ({accuracy:.1f}%)")
        else:
            st.error(f"üìö Deutliche Abweichungen ({accuracy:.1f}%)")
        
        # Vergleich anzeigen
        st.write("**Vergleich mit Experteneinsch√§tzung:**")
        for i, (user, expert) in enumerate(zip(user_probabilities, expert_probs)):
            diff = abs(user - expert)
            marker = "‚úÖ" if diff <= tolerance else "‚ùå"
            st.write(f"{marker} **{question_data['hypotheses'][i]}** - Sie: {user}% | Experte: {expert}%")
        
        with st.expander("üìö Probabilistische Begr√ºndung", expanded=True):
            st.info(question_data["explanation"])
        
        self.show_next_button(question_data)
    
    def evaluate_intervention_strategy(self, user_answers, question_data):
        """Bewertet Interventions-Strategien"""
        user_indices = [question_data["strategic_options"].index(ans) for ans in user_answers]
        correct_indices = question_data["recommended_strategies"]
        
        st.subheader("üí° Personzentrierte Intervention")
        
        if set(user_indices) == set(correct_indices):
            st.success("üéâ Optimales Interventionsverst√§ndnis!")
            st.session_state.score += 1
        else:
            st.warning("üëç Gute Ans√§tze - Feinabstimmung m√∂glich")
        
        with st.expander("üìö Interventionslogik", expanded=True):
            st.info(question_data["explanation"])
        
        self.show_next_button(question_data)
    
    def evaluate_complex_combination(self, user_answers, question_data):
        """Bewertet komplexe Kombinationsfragen"""
        user_indices = [question_data["dimension_combinations"].index(ans) for ans in user_answers]
        correct_indices = question_data["correct_combination"]
        
        st.subheader("üß© Komplexe Dimensions-Interaktion")
        
        if set(user_indices) == set(correct_indices):
            st.success("üéâ Exzellente Analyse komplexer Muster!")
            st.session_state.score += 1
        else:
            st.warning("üìö Interaktionseffekte noch vertiefen")
        
        with st.expander("üìö Interaktionsanalyse", expanded=True):
            st.info(question_data["explanation"])
        
        self.show_next_button(question_data)
    
    def show_next_button(self, question_data):
        """Zeigt den Next-Button - KORRIGIERTE UND FUNKTIONIERENDE VERSION"""
        st.markdown("---")
        
        # WICHTIG: Ein eindeutiger Key f√ºr jeden Next-Button
        next_key = f"next_btn_{question_data['id']}_{st.session_state.current_question}"
        
        if st.button("‚û°Ô∏è **Weiter zur n√§chsten Frage**", type="primary", use_container_width=True, key=next_key):
            # Zustand sicher aktualisieren
            st.session_state.current_question += 1
            
            # Expliziter Rerun - das ist der Schl√ºssel!
            st.rerun()
    
    def show_results(self):
        """Zeigt die Quiz-Ergebnisse"""
        st.header("üìä Quiz abgeschlossen!")
        
        total = len(st.session_state.quiz_questions)
        score = st.session_state.score
        percentage = (score / total) * 100
        
        # Zeitberechnung
        if 'start_time' in st.session_state:
            time_used = time.time() - st.session_state.start_time
            minutes = int(time_used // 60)
            seconds = int(time_used % 60)
            time_str = f"{minutes:02d}:{seconds:02d}"
        else:
            time_str = "Unbekannt"
        
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Richtige Antworten", f"{score}/{total}")
        with col2:
            st.metric("Erfolgsquote", f"{percentage:.1f}%")
        with col3:
            st.metric("Bearbeitungszeit", time_str)
        
        # Qualitatives Feedback
        st.subheader("üéØ Diagnostische Urteilsf√§higkeit")
        
        if percentage >= 80:
            st.success("""
            **üèÜ Exzellente diagnostische Kompetenz!**
            - Sie denken in Wahrscheinlichkeiten und Mehrdeutigkeiten
            - Ber√ºcksichtigen situative Faktoren systematisch  
            - Haben ein differenziertes Verst√§ndnis komplexer Muster
            """)
        elif percentage >= 60:
            st.warning("""
            **‚≠ê Gute klinische Urteilsf√§higkeit!**
            - Sie erkennen multiple Interpretationsm√∂glichkeiten
            - Haben Grundverst√§ndnis f√ºr Person-Situation-Interaktionen
            - Vertiefen Sie sich in komplexere Fallkonstellationen
            """)
        else:
            st.error("""
            **üìö Entwicklungsbereich: Differenzierte Verhaltensdeutung**
            - √úben Sie, in Wahrscheinlichkeiten statt Gewissheiten zu denken
            - Achten Sie st√§rker auf situative √úberlagerungen
            - Trainieren Sie das Erkennen von Dimensions-Interaktionen
            """)
        
        # Neustart-Button
        st.markdown("---")
        if st.button("üîÑ Quiz neu starten", type="primary", use_container_width=True, key="btn_restart"):
            # Session State komplett zur√ºcksetzen
            for key in list(st.session_state.keys()):
                if key != 'quiz_initialized':
                    del st.session_state[key]
            st.rerun()
